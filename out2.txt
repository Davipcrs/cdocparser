 @ID ## file_preprocessor.c @NL
 @ID # HEHE @NL

	@DOCSTART
	This function is the function responsible to implement the file loading.@NL
	In the input is a char point (A string) for the path of the file. @NL
	@DOCEND
	 read file content
 free(fileContent);
 free(auxiliarChar);
 check errors
 check errors
 One extra byte for the null terminator
 add the null terminator
 @CBS
bool isSingleLine = false;
	bool isInMultiLine = false;
	bool isCodeBlock = false;
	int saveIndexOfStartComment_aux1 = 0;
	int saveIndexOfStartComment_aux2 = 0;
	int readIndex = 0;
	int inputLength = strlen(input);
	int returnStringWriteIndex = 0;
	// char returnString[inputLength + 1];
	char *returnString = realloc(input, (inputLength + 1) * sizeof(char));

	//@CBE Check if is in no block and if is a blank space
 Check if is a single line comment
 Check if is a MULTI line comment
 Treat the comments:
 Check single line end
 Fim do comentário de linha única
 Enquanto estivermos dentro de um comentário multilinha, copiamos até encontrar '*/'
 Fim do comentário multilinha
 needs to debug the CBE.
 printf("%s\n", input + readIndex);

	// check errors
	if (ferror(file))
	{
		perror("Error reading file");
		free(fileContent);
		fclose(file);
		return "File read error";
	}

	fclose(file);

	// check errors
	fileContent = realloc(fileContent, totalSize + 1); // One extra byte for the null terminator
	if (fileContent == NULL)
	{
		perror("Memory allocation failed");
		return "mem error";
	}

	// add the null terminator
	fileContent[totalSize] = '\0';

	return fileContent;
}

char *removeNonComments(char *input)
{
	// @CBS

	bool isSingleLine = false;
	bool isInMultiLine = false;
	bool isCodeBlock = false;
	int saveIndexOfStartComment_aux1 = 0;
	int saveIndexOfStartComment_aux2 = 0;
	int readIndex = 0;
	int inputLength = strlen(input);
	int returnStringWriteIndex = 0;
	// char returnString[inputLength + 1];
	char *returnString = realloc(input, (inputLength + 1) * sizeof(char));

	//@CBE

	if (returnString == NULL)
	{
		perror("memory error");
		return "Insert comments in the file";
	}

	while (readIndex < inputLength)
	{
		// Check if is in no block and if is a blank space
		if (!isSingleLine && !isInMultiLine && isspace(input[readIndex]))
		{
			readIndex++;
			continue;
		}

		// Check if is a single line comment
		if (!isSingleLine && input[readIndex] == '/' && input[readIndex + 1] == '/')
		{
			isSingleLine = true;
			saveIndexOfStartComment_aux1 = readIndex;
			saveIndexOfStartComment_aux2 = readIndex + 1;
		}

		// Check if is a MULTI line comment
		if (!isInMultiLine && input[readIndex] == '/' && input[readIndex + 1] == '*')
		{
			isInMultiLine = true;
			saveIndexOfStartComment_aux1 = readIndex;
			saveIndexOfStartComment_aux2 = readIndex + 1;
		}

		if (!isCodeBlock && (strncmp(input + readIndex, CODEBLOCKSTART, 15) == 0 || strncmp(input + readIndex, CBS, 4) == 0))
		{
			isCodeBlock = true;
			continue;
		}

		// Treat the comments:
		if (isSingleLine)
		{
			// Check single line end
			if (input[readIndex] == '\n')
			{
				isSingleLine = false; // Fim do comentário de linha única
			}
			if (saveIndexOfStartComment_aux1 == readIndex)
			{
				readIndex++;
			}
			if (saveIndexOfStartComment_aux2 == readIndex)
			{
				readIndex++;
			}
			returnString[returnStringWriteIndex] = input[readIndex];
			returnStringWriteIndex++;
			readIndex++;
			continue;
		}

		// Enquanto estivermos dentro de um comentário multilinha, copiamos até encontrar '*/'
		if (isInMultiLine)
		{
			if (input[readIndex] == '*' && input[readIndex + 1] == '/')
			{
				isInMultiLine = false;
				continue; // Fim do comentário multilinha
			}
			if (saveIndexOfStartComment_aux1 == readIndex)
			{
				readIndex++;
			}
			if (saveIndexOfStartComment_aux2 == readIndex)
			{
				readIndex++;
			}
			returnString[returnStringWriteIndex] = input[readIndex];
			returnStringWriteIndex++;
			readIndex++;
			continue;
		}

		while (isCodeBlock)
		// needs to debug the CBE.
		{
			// printf("%s\n", input + readIndex);
			if (strncmp(input + readIndex - 13, CODEBLOCKEND, 13) == 0 || strncmp(input + readIndex - 4, CBE, 4) == 0)
			{

				isCodeBlock = false;
				break;
			}
			returnString[returnStringWriteIndex] = input[readIndex];
			returnStringWriteIndex++;
			readIndex++;
		}

		readIndex++;
	}
	returnString[readIndex] = '\0';
	return returnString;
}